# -*- coding: utf-8 -*-
"""cse422 lab2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PsxozSoakbnokIT3lZhJGGIPYHVP_MFY
"""

#PART 1

import random

def choromosome(intial_production):
  choromosome= []
  for i in range(len(intial_production)):
    size = ""
    for k,v in intial_production[i].items():
      if v>=10:
        size+=str(v)
      else:
        size+="0"
        size+=str(v)
    choromosome.append(size)
  return choromosome


def fitness(choromosome,historical_price,Capital):
  fitness_score = {}
  for i in choromosome:
    Capital=1000
    for j in range(10):
      stop_loss = int(i[:2])
      take_profit = int(i[2:4])
      trade_percentage = int(i[-2:])/100
      trade_size = Capital*trade_percentage
      if historical_price[j] < 0 and historical_price[j]<(-stop_loss) :
        profit = trade_size*((-stop_loss)/100)
      elif historical_price[j] > take_profit:
        profit = trade_size*(take_profit/100)
      else:
        profit = trade_size*(historical_price[j]/100)
      Capital=Capital+profit
    fitness_score[i] = Capital-1000
  return fitness_score

def parents(chr):
  random_parents = random.sample(chr,2)
  chr.remove(random_parents[0])
  chr.remove(random_parents[1])
  return random_parents

def cross_over(parent1,parent2):
  val = random.randint(0,len(parent1))
  child1 = parent1[:val]+parent2[val:]
  child2 = parent2[:val]+parent1[val:]
  return [child1,child2]

def mutation(child1,child2,mutation_rate):
  rate = random.uniform(0,1)
  if rate <= mutation_rate:
    index = random.randint(0,len(child1)-1)
    replace_value = random.randint(0,9)
    child1 = child1[:index]+str(replace_value)+child1[index+1:]
    index = random.randint(0,len(child2)-1)
    replace_value = random.randint(0,9)
    child2 = child2[:index]+str(replace_value)+child2[index+1:]
  return [child1,child2]



def genetic(chr,historical_price,Capital,generation,mutation_rate):
  fit = fitness(chr,historical_price,Capital)
  for i in range(generation):
    new_population = []
    paren = parents(chr)
    parent1=paren[0]
    parent2=paren[1]
    childrens = cross_over(parent1,parent2)
    child1,child2 = childrens[0],childrens[1]
    mu_child1,mu_child2 = mutation(child1,child2,mutation_rate)
    chr.append(mu_child1)
    chr.append(mu_child2)
    fit = fitness(chr,historical_price,Capital)

  return fit

mutation_rate = 0.05
Capital= 1000
historical_price = [-1.2,3.4,-0.8,2.1,-2.5,1.7,-0.3,5.8,-1.1,3.5]
generation = 10
intial_production = [{"stop_loss": 2,"take_profit": 5,"trade_size": 20}, {"stop_loss": 3,"take_profit": 7,"trade_size": 30}, {"stop_loss": 3,"take_profit": 4,"trade_size": 25}, {"stop_loss": 4,"take_profit": 6,"trade_size": 15}]
chr = choromosome(intial_production)
res = genetic(chr,historical_price,Capital,generation,mutation_rate)
prof = max(res,key= res.get)
stop_loss = int(prof[:2])
take_profit = int(prof[2:4])
trade_size = int(prof[4:])
print(f"best_strategy: stop_loss: {stop_loss}, take_profit: {take_profit}, trade_size: {trade_size}")
print(f"Final_profit: {res[prof]}")

#PART 2

import random

def initial_choromosome(intial_production):
  choromosome= []
  for i in range(len(intial_production)):
    size = ""
    for k,v in intial_production[i].items():
      if v>=10:
        size+=str(v)
      else:
        size+="0"
        size+=str(v)
    choromosome.append(size)
  return choromosome

def two_point_crossover(p1,p2):
  index1 = random.randint(0,len(p1))
  index2 = random.randint(index1,len(p2))
  c1 = p1[:index1]+p2[index1:index2]+p1[index2:]
  c2 = p2[:index1]+p1[index1:index2]+p2[index2:]
  return [c1,c2]


intial_production = [{"stop_loss": 2,"take_profit": 5,"trade_size": 20}, {"stop_loss": 5,"take_profit": 7,"trade_size": 30}, {"stop_loss": 3,"take_profit": 4,"trade_size": 25}, {"stop_loss": 4,"take_profit": 6,"trade_size": 15}]
first_chr = initial_choromosome(intial_production)
random_parents = random.sample(first_chr,2)
p1,p2 = random_parents[0],random_parents[1]
t_p_crs = two_point_crossover(p1,p2)
print(f"So the two resultant offsprings are: {t_p_crs[0]} & {t_p_crs[1]}")